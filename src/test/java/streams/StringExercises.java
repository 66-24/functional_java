package streams;

import org.junit.jupiter.api.Test;

import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.logging.Logger;
import java.util.stream.Collectors;

public class StringExercises {
    private final List<String> strings = Arrays.asList("this", "is", "a",
            "list", "of", "strings");

    @Test
    public void stringLengthSort_InnerClass() {     // Java 5, 6, 7
        strings.sort(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.length() - s2.length();
            }
        });
        System.out.println(strings);
    }

    @Test
    public void stringLengthSort_lambda() {
        // Use lambda for the Comparator (reverse sort)
        strings.sort((s1, s2) -> s2.length() - s1.length());
        System.out.println(strings);
        // Use the "sorted" method on Stream
    }

    private int compareStrings(String s1, String s2) {
        return s1.length() - s2.length();
    }

    @Test  // Use a lambda that calls 'compareStrings' directly
    public void stringLengthSort_methodCall() {
        strings.sort((s1, s2) -> compareStrings(s1, s2));
        System.out.println(strings);
    }

    @Test  // Use a method ref to 'compareStrings'
    public void stringLengthSort_methodRef() {
        strings.sort(this::compareStrings);
        System.out.println(strings);
    }

    @Test  // Use Comparator.comparingInt
    public void stringLengthSort_comparingInt() {
        strings.sort(Comparator.comparingInt(String::length)
                .thenComparing(Comparator.naturalOrder()));
        System.out.println(strings);
    }

    @Test
    public void demoCollectors() {
        List<String> result = strings.stream()
                .map(String::toUpperCase)
                .collect(Collectors.toList());
        System.out.println(result);
        System.out.println(result.getClass()
                .getName());

        // Get only strings of even length
        // Add them to a LinkedList
        LinkedList<String> evenLengths = strings.stream()
                .filter(s -> s.length() % 2 == 0)
                //.collect(Collectors.toCollection(() -> new LinkedList<>()));
                .collect(Collectors.toCollection(LinkedList::new));
        System.out.println(evenLengths);
        System.out.println(evenLengths.getClass()
                .getName());

        // Add the strings to a map of string to length
        Map<String, Integer> map = strings.stream()
                //.collect(Collectors.toMap(s -> s, s -> s.length())); // two lambda expressions
                //.collect(Collectors.toMap(s -> s, String::length));  // lambda and method ref
                .collect(Collectors.toMap(Function.identity(), String::length));
        System.out.println(map);

        // Filter out nulls, then print even-length strings
        List<String> stringsWithNulls = Arrays.asList("this", null, "is", null, "a", "test", null);
        List<String> evens = stringsWithNulls.stream()
                //.filter(s -> s != null && s.length() % 2 == 0) // guard condition in a short-circuiting logical AND
                //.filter(s -> s != null)
                .filter(Objects::nonNull)
                .filter(s -> s.length() % 2 == 0)
                .collect(Collectors.toList());
        System.out.println(evens);

        Logger logger = Logger.getLogger(StringExercises.class.getName());
        Consumer<String> log = logger::info;
        Consumer<String> print = System.out::println;

        // Function composition
        Predicate<String> nonNull = Objects::nonNull;
        Predicate<String> evenLength = s -> s.length() % 2 == 0;
        stringsWithNulls.stream()
                .filter(nonNull.and(evenLength))
                .forEach(log.andThen(print));

        // f: A -> B, g: B -> C, (g.f)(x) = g(f(x)), A -> C
        strings.stream()
                .forEach(s -> predicateWithFunctionWithConsumer(
                        nonNull,
                        Object::toString,
                        System.out::println, s));
    }

    private <T> Predicate<T> combineThree(Predicate<T> predicate1,
                                          Predicate<T> predicate2,
                                          Predicate<T> predicate3) {
        return predicate1.and(predicate2)
                .and(predicate3);
    }

    private <T, R> void predicateWithFunctionWithConsumer(Predicate<T> predicate,
                                                          Function<T, R> function,
                                                          Consumer<R> consumer,
                                                          T t) {
        if (predicate.test(t)) {
            R r = function.apply(t);
            consumer.accept(r);
        }
    }

    // generated by GitHub Copilot
    private <A, B, C> Function<A, C> compose(Function<A, B> f, Function<B, C> g) {
        return x -> g.apply(f.apply(x));
    }

}
